=== cherry-charm\src\App.tsx ===

import { useState, useEffect } from "react";
import { Canvas } from "@react-three/fiber";
import Interface from "./interface/Interface";
import Game from "./Game";

// Define the user management server URL
const userManagementServer = "http://127.0.0.1:5000";

const App = () => {
  const [windowWidth] = useState(window.innerWidth);
  const cameraPositionZ = windowWidth > 500 ? 30 : 40;

  // State to hold userId (or username) and token
  const [userId, setUserId] = useState<string | null>(null);
  const [token, setToken] = useState<string | null>(null);

  useEffect(() => {
    const searchParams = new URLSearchParams(window.location.search);
    const id = searchParams.get('username') || "defaultUserId";
    const token = searchParams.get('token') || null;

    setUserId(id);
    setToken(token);

    if (token) {
      // Optionally store the token in local storage
      localStorage.setItem('authToken', token);

      // Verify the token
      fetch(`${userManagementServer}/verify-token`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ token: token, username: id }),
      })
        .then((response) => {
          // Log the status and the JSON response for debugging
          console.log("Token verification response status:", response.status);
          return response.json();
        })
        .then((data) => {
          console.log("Token verification response data:", data);
          if (data.message !== "Token is valid") {
            // If token is invalid, redirect to the login page on the other process/port
            //window.location.href = `${userManagementServer}/login`;
          }
        })
        .catch((error) => {
          console.error("Error verifying token:", error);
          // In case of an error (e.g., network issue), redirect to the login page
          //window.location.href = `${userManagementServer}/login`;
        });
    } else {
      // If there's no token, redirect to login
      //window.location.href = `${userManagementServer}/login`;
    }
  }, []);

  console.log("userId:", userId);
  console.log("token:", token);

  // Pass userId and token to the components
  return (
    <>
      <Interface userId={userId} token={token} />
      <Canvas camera={{ fov: 75, position: [0, 0, cameraPositionZ] }}>
        <Game userId={userId}
              token={token}/>
      </Canvas>
    </>
  );
};

export default App;


=== cherry-charm\src\Bars.tsx ===



import * as THREE from "three";

const squareGeometry = new THREE.BoxGeometry();
const barMaterial = new THREE.MeshStandardMaterial({ color: "#2A1558" });

const Bars = () => {
  return (
    <>
      <mesh
        position={[0, 3.5, 10.5]}
        scale={[22.5, 0.5, 0.5]}
        geometry={squareGeometry}
        material={barMaterial}
      />
      <mesh
        position={[0, -3.75, 10.5]}
        scale={[22.5, 0.5, 0.5]}
        geometry={squareGeometry}
        material={barMaterial}
      />
      <mesh
        position={[-11, 0, 10.5]}
        rotation-z={Math.PI / 2}
        scale={[7, 0.5, 0.5]}
        geometry={squareGeometry}
        material={barMaterial}
      />
      <mesh
        position={[11, 0, 10.5]}
        rotation-z={Math.PI / 2}
        scale={[7, 0.5, 0.5]}
        geometry={squareGeometry}
        material={barMaterial}
      />
    </>
  );
};

export default Bars;


=== cherry-charm\src\Button.tsx ===



import * as THREE from "three";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";

type GLTFResult = GLTF & {
  nodes: {
    Cube_Subscribe_0: THREE.Mesh;
  };
};

const Button = (props: JSX.IntrinsicElements["group"]) => {
  const { nodes } = useGLTF("/models/button.glb") as GLTFResult;

  const material = new THREE.MeshStandardMaterial({ color: "#3b0873" });

  return (
    <group {...props} dispose={null}>
      <group
        position={[713.17, 1157.193, -723.814]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[130.456, 19.364, 45.456]}
      >
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Cube_Subscribe_0.geometry}
          material={material}
          position={[-5.454, -37.484, -26.142]}
        ></mesh>
      </group>
    </group>
  );
};

useGLTF.preload("/models/button.glb");
export default Button;


=== cherry-charm\src\Casing.tsx ===



import * as THREE from "three";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";

type GLTFResult = GLTF & {
  nodes: {
    ["Node-Mesh"]: THREE.Mesh;
    ["Node-Mesh_1"]: THREE.Mesh;
  };
  materials: {
    mat16: THREE.MeshStandardMaterial;
    mat23: THREE.MeshStandardMaterial;
  };
};

const Casing = (props: JSX.IntrinsicElements["group"]) => {
  const { nodes, materials } = useGLTF("/models/casing.glb") as GLTFResult;
  return (
    <group {...props} dispose={null}>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes["Node-Mesh"].geometry}
        material={materials.mat16}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes["Node-Mesh_1"].geometry}
        material={materials.mat23}
      />
    </group>
  );
};

useGLTF.preload("/models/casing.glb");
export default Casing;


=== cherry-charm\src\Game.tsx ===

import { useRef } from "react";
import { OrbitControls } from "@react-three/drei";
import Lights from "./lights/Lights";
import SlotMachine from "./SlotMachine";

interface GameProps {
  userId: string | null;  // Accept userId as a prop
}

const Game = ({ userId }: GameProps) => {
  const slotMachineRef = useRef();

  return (
    <>
      <color args={["#141417"]} attach="background" />
      <OrbitControls enableRotate={false} /> {/* Disable rotation */}
      <Lights />
      <SlotMachine ref={slotMachineRef} value={[1, 2, 3]} userId={userId} />  {/* Pass userId to SlotMachine */}
    </>
  );
};

export default Game;


=== cherry-charm\src\main.tsx ===



import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App.tsx";
import "./style.css";

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


=== cherry-charm\src\Reel.tsx ===



import { useRef, forwardRef, ForwardedRef } from "react";
import { useFrame, useLoader } from "@react-three/fiber";
import { useGLTF } from "@react-three/drei";
import * as THREE from "three";
import { GLTF } from "three-stdlib";
// import useGame from "./stores/store";
import { WHEEL_SEGMENT } from "./utils/constants";

type GLTFResult = GLTF & {
  nodes: {
    Cylinder: THREE.Mesh;
    Cylinder_1: THREE.Mesh;
  };
  materials: {
    ["Material.001"]: THREE.MeshStandardMaterial;
    ["Material.002"]: THREE.MeshStandardMaterial;
  };
};

type ReelProps = JSX.IntrinsicElements["group"] & {
  value?: number;
  reelSegment: number;
  map: number;
};

const Reel = forwardRef(
  (props: ReelProps, ref: ForwardedRef<THREE.Group>): JSX.Element => {
    // const sparkles = useGame((state) => state.sparkles);

    const { reelSegment } = props;
    const { nodes, materials } = useGLTF("/models/reel.glb") as GLTFResult;
    const reel = useRef<THREE.Group>(null);

    // Color maps
    const colorMap0 = useLoader(THREE.TextureLoader, "/images/reel_0.png");
    const colorMap1 = useLoader(THREE.TextureLoader, "/images/reel_1.png");
    const colorMap2 = useLoader(THREE.TextureLoader, "/images/reel_2.png");
    let activeColorMap;
    switch (props.map) {
      case 0:
        activeColorMap = colorMap0;
        break;
      case 1:
        activeColorMap = colorMap1;
        break;
      case 2:
        activeColorMap = colorMap2;
        break;
    }

    useFrame(() => {
      if (reel.current) reel.current.rotation.x += 0.025;
    });

    return (
      <group {...props} ref={ref} dispose={null}>
        <group
          rotation={[reelSegment * WHEEL_SEGMENT - 0.2, 0, -Math.PI / 2]}
          scale={[1, 0.29, 1]}
        >
          <mesh castShadow receiveShadow geometry={nodes.Cylinder.geometry}>
            <meshStandardMaterial map={activeColorMap} />
            {/* {sparkles && (
              <Sparkles count={200} scale={2.5} size={10} speed={4} />
            )} */}
          </mesh>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.Cylinder_1.geometry}
            material={materials["Material.002"]}
          />
        </group>
      </group>
    );
  }
);

useGLTF.preload("/models/reel.glb");
export default Reel;


=== cherry-charm\src\SlotMachine.tsx ===

import {
  useRef,
  useEffect,
  forwardRef,
  useImperativeHandle,
  useState,
} from "react";
import { useFrame } from "@react-three/fiber";
import { Text } from "@react-three/drei";
import * as THREE from "three";
import useGame from "./stores/store";
import devLog from "./utils/functions/devLog";
import segmentToFruit from "./utils/functions/segmentToFruit";
import endgame from "./utils/functions/endgame";
import { WHEEL_SEGMENT } from "./utils/constants";
import Reel from "./Reel";
import Button from "./Button";

interface ReelGroup extends THREE.Group {
  reelSegment?: number;
  reelPosition?: number;
  reelSpinUntil?: number;
  reelStopSegment?: number;
}

interface SlotMachineProps {
  value: (0 | 1 | 2 | 3 | 4 | 5 | 6 | 7)[];
  userId: string;  // Assuming userId is passed as a prop
}

const SlotMachine = forwardRef(({ value, userId }: SlotMachineProps, ref) => {
  const fruit0 = useGame((state) => state.fruit0);
  const fruit1 = useGame((state) => state.fruit1);
  const fruit2 = useGame((state) => state.fruit2);
  const setFruit0 = useGame((state) => state.setFruit0);
  const setFruit1 = useGame((state) => state.setFruit1);
  const setFruit2 = useGame((state) => state.setFruit2);
  const phase = useGame((state) => state.phase);
  const start = useGame((state) => state.start);
  const end = useGame((state) => state.end);
  const addSpin = useGame((state) => state.addSpin);
  const coins = useGame((state) => state.coins);
  const updateCoins = useGame((state) => state.updateCoins);
  const fetchCoins = useGame((state) => state.fetchCoins);

  // Fetch initial coins when the component mounts
  useEffect(() => {
    console.log("Component mounted, userId:", userId);
    if (userId) {
      fetchCoins(userId);
    } else {
      console.error("userId is undefined. Cannot fetch initial coins.");
    }
  }, [userId, fetchCoins]);

  useEffect(() => {
    devLog("PHASE: " + phase);

    if (phase === "idle") {
      console.log("User ID:", userId); // Überprüfen, ob userId definiert ist
      const winnings = endgame(fruit0, fruit1, fruit2);
      console.log("Winnings:", winnings);
      if (userId && winnings !== 0) {  // Nur wenn userId definiert ist und winnings nicht null sind
        console.log("Updating coins for userId:", userId, "with winnings:", winnings);
        updateCoins(userId, winnings);
      } else {
        console.warn("Skipping updateCoins due to missing userId or winnings being 0.");
      }
    }
  }, [phase, fruit0, fruit1, fruit2, updateCoins, userId]);

  const reelRefs = [
    useRef<ReelGroup>(null),
    useRef<ReelGroup>(null),
    useRef<ReelGroup>(null),
  ];

  const spinSlotMachine = () => {
    console.log("Spinning slot machine");
    start();
    const min = 15;
    const max = 30;
    const getRandomStopSegment = () =>
      Math.floor(Math.random() * (max - min + 1)) + min;

    const spinReel = (reelIndex: number) => {
      const reel = reelRefs[reelIndex].current;
      if (reel) {
        // Reset rotation
        reel.rotation.x = 0;
        // Reset all attributes
        reel.reelSegment = 0;
        reel.reelPosition = 0;
        reel.reelSpinUntil = 0;
        reel.reelStopSegment = 0;
        // Clear fruits from previous spins
        setFruit0("");
        setFruit1("");
        setFruit2("");
        const stopSegment = getRandomStopSegment();
        devLog(`Stop segment of reel ${reelIndex}: ${stopSegment}`);

        reel.reelSpinUntil = stopSegment;
      }
    };

    spinReel(0);
    spinReel(1);
    spinReel(2);
  };

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (event.code === "Space") {
        if (phase !== "spinning") {
          if (coins > 0) {
            console.log("Space key pressed, spinning slot machine");
            spinSlotMachine();
            addSpin();
            if (userId) {
              updateCoins(userId, -1);
            } else {
              console.error("userId is undefined, cannot update coins.");
            }
          } else {
            console.warn("Not enough coins to spin the slot machine.");
          }
        } else {
          console.log("Slot machine is already spinning.");
        }
      }
    };

    document.addEventListener("keydown", handleKeyDown);

    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [phase, coins, userId, spinSlotMachine, addSpin, updateCoins]);

  useFrame(() => {
    for (let i = 0; i < reelRefs.length; i++) {
      const reel = reelRefs[i].current;
      if (reel) {
        if (reel.reelSpinUntil !== undefined) {
          if (reel.reelSegment === undefined) {
            reel.reelSegment = 0;
          }

          const targetRotationX =
            (reel.reelSpinUntil - reel.reelSegment) * WHEEL_SEGMENT;
          const rotationSpeed = 0.1;

          if (reel.rotation.x < targetRotationX) {
            reel.rotation.x += rotationSpeed;
            reel.reelSegment = Math.floor(reel.rotation.x / WHEEL_SEGMENT);
          } else if (reel.rotation.x >= targetRotationX) {
            // The reel has stopped spinning at the desired segment
            setTimeout(() => {
              end();
            }, 1000);
            const fruit = segmentToFruit(i, reel.reelSegment);

            if (fruit) {
              switch (i) {
                case 0:
                  setFruit0(fruit);
                  break;
                case 1:
                  setFruit1(fruit);
                  break;
                case 2:
                  setFruit2(fruit);
                  break;
              }
            }

            devLog(
              `Reel ${i + 1} stopped at segment ${reel.reelSegment} ${fruit}`
            );
            reel.reelSpinUntil = undefined; // Reset reelSpinUntil to stop further logging
          }
        }
      }
    }
  });

  useImperativeHandle(ref, () => ({
    reelRefs,
  }));

  const [buttonZ, setButtonZ] = useState(0);
  const [buttonY, setButtonY] = useState(-13);

  const [textZ, setTextZ] = useState(1.6);
  const [textY, setTextY] = useState(-14);

  return (
    <>
      <Reel
        ref={reelRefs[0]}
        value={value[0]}
        map={0}
        position={[-7, 0, 0]}
        rotation={[0, 0, 0]}
        scale={[10, 10, 10]}
        reelSegment={0}
      />
      <Reel
        ref={reelRefs[1]}
        value={value[1]}
        map={1}
        position={[0, 0, 0]}
        rotation={[0, 0, 0]}
        scale={[10, 10, 10]}
        reelSegment={0}
      />
      <Reel
        ref={reelRefs[2]}
        value={value[2]}
        map={2}
        position={[7, 0, 0]}
        rotation={[0, 0, 0]}
        scale={[10, 10, 10]}
        reelSegment={0}
      />
      <Button
        scale={[0.055, 0.045, 0.045]}
        position={[0, buttonY, buttonZ]}
        rotation={[-Math.PI / 8, 0, 0]}
        onClick={() => {
          if (phase !== "spinning") {
            if (coins > 0) {
              console.log("Button clicked, spinning slot machine");
              spinSlotMachine();
              addSpin();
              if (userId) {
                updateCoins(userId, -1);
              } else {
                console.error("userId is undefined, cannot update coins.");
              }
            } else {
              console.warn("Not enough coins to spin the slot machine.");
            }
          }
        }}
        onPointerDown={() => {
          setButtonZ(-1);
          setButtonY(-13.5);
        }}
        onPointerUp={() => {
          setButtonZ(0);
          setButtonY(-13);
        }}
      />
      <Text
        color="white"
        anchorX="center"
        anchorY="middle"
        position={[0, textY, textZ]}
        rotation={[-Math.PI / 8, 0, 0]}
        fontSize={3}
        font="./fonts/nickname.otf"
        onPointerDown={() => {
          setTextZ(1.3);
          setTextY(-14.1);
        }}
        onPointerUp={() => {
          setTextZ(1.6);
          setTextY(-14);
        }}
      >
        {phase === "idle" ? "GIRAR" : "GIRANDO"}
      </Text>
    </>
  );
});

export default SlotMachine;


=== cherry-charm\src\style.css ===

@import url("https://fonts.googleapis.com/css2?family=Paytone+One&display=swap");
@import url("https://fonts.googleapis.com/css2?family=Inter:wght@500&display=swap");

* {
  margin: 0;
  padding: 0;
  font-family: "Paytone One", sans-serif;
  user-select: none;
  -moz-user-drag: none;
  -webkit-user-drag: none;
  -moz-user-select: none;
  -webkit-user-select: none;
  -ms-user-select: none;
  box-sizing: border-box;
  overflow: hidden;
  touch-action: none;
}

html,
body,
#root {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}


=== cherry-charm\src\interface\Interface.tsx ===



import useGame from "../stores/store";
import Modal from "./modal/Modal";
import HelpButton from "./helpButton/HelpButton";
import "./style.css";

const Interface = () => {
  // const phase = useGame((state) => state.phase);
  const modal = useGame((state) => state.modal);
  const coins = useGame((state) => state.coins);
  const spins = useGame((state) => state.spins);

  return (
    <>
      {/* Help Button */}
      <HelpButton />

      {/* Modal */}
      {modal && <Modal />}

      {/* Logo */}
      <a
        target="_blank"
      >
        <img className="logo" src="./images/logo.png" alt="" />
      </a>

      <div className="interface">
        {/* Coins */}
        <div className="coins-section">
          <div className="coins-number">{coins}</div>
          <img className="coins-image" src="./images/coin.png" />
        </div>

        {/* Spins */}
        <div className="spins-section">
          <div className="spins-number">{spins}</div>
        </div>

        {/* Phase */}
        {/* <div >{phase.toUpperCase()}</div> */}
      </div>
    </>
  );
};

export default Interface;


=== cherry-charm\src\interface\style.css ===

.interface {
  pointer-events: none;
  z-index: 1;
  position: absolute;
  margin: 1em;
  color: #fff;
}

.logo {
  width: min(300px, 25vw);
  transform: rotate(-5deg);
  position: fixed;
  top: 0;
  left: 0;
  margin: 0.5em;
  cursor: pointer;
  z-index: 1;
}

.spins-section {
  position: fixed;
  bottom: 0;
  left: 0;
  margin: 1em;
}

.spins-number {
  font-size: min(130px, 11vw);
  text-shadow: min(7px, 1vw) min(7px, 1vw) 0px #6913c5;
  width: 400px;
}

.coins-section {
  position: fixed;
  bottom: 0;
  right: 0;
  display: flex;
  align-items: center;
  justify-content: space-around;
  margin: 1em;
}

.coins-number {
  font-size: min(130px, 11vw);
  width: 400px;
  text-align: right;
  text-shadow: min(7px, 1vw) min(7px, 1vw) 0px #6913c5;
}

.coins-image {
  margin-top: 1vw;
  margin-left: 2vw;
  width: min(130px, 11vw);
}


=== cherry-charm\src\interface\helpButton\HelpButton.tsx ===



import useGame from "../../stores/store";
import "./style.css";

const HelpButton = () => {
  const { setModal } = useGame();

  const handleHelp = () => {
    setModal(true);
  };

  return <div onClick={handleHelp} className="help-button" />;
};

export default HelpButton;


=== cherry-charm\src\interface\helpButton\style.css ===

.help-button {
  position: fixed;
  top: 12px;
  right: 12px;
  background-image: url("/images/help.svg");
  height: min(40px, 10vw);
  width: min(40px, 10vw);
  cursor: pointer;
  z-index: 1;
}


=== cherry-charm\src\interface\modal\Modal.tsx ===

// Copyright (c) 2023 Michael Kolesidis <michael.kolesidis@gmail.com>
// Licenciado bajo la GNU Affero General Public License v3.0.
// https://www.gnu.org/licenses/gpl-3.0.html

import useGame from "../../stores/store";
import "./style.css";

const Modal = () => {
  const { setModal } = useGame();

  return (
      <div className="modal" onClick={() => setModal(false)}>
        <div className="modal-box" onClick={(e) => e.stopPropagation()}>
          <div className="modal-main">
            <div className="modal-text">
              Haz clic en el botón SPIN o presiona ESPACIO para girar.
            </div>
            <div className="modal-text">
              <img className="modal-image" src="./images/cherry.png" />
              <img className="modal-image" src="./images/cherry.png" />
              <img className="modal-image" src="./images/cherry.png" />
              <span> Ganá 50 </span>
              <img className="modal-image" src="./images/coin.png" />
            </div>
            <div className="modal-text">
              <img className="modal-image" src="./images/apple.png" />
              <img className="modal-image" src="./images/apple.png" />
              <img className="modal-image" src="./images/apple.png" />
              <span> Ganá 20 </span>
              <img className="modal-image" src="./images/coin.png" />
            </div>
            <div className="modal-text">
              <img className="modal-image" src="./images/banana.png" />
              <img className="modal-image" src="./images/banana.png" />
              <img className="modal-image" src="./images/banana.png" />
              <span> Ganá 15 </span>
              <img className="modal-image" src="./images/coin.png" />
            </div>
            <div className="modal-text">
              <img className="modal-image" src="./images/lemon.png" />
              <img className="modal-image" src="./images/lemon.png" />
              <img className="modal-image" src="./images/lemon.png" />
              <span> Ganá 3 </span>
              <img className="modal-image" src="./images/coin.png" />
            </div>
            <div className="modal-text">
              <img className="modal-image" src="./images/cherry.png" />
              <img className="modal-image" src="./images/cherry.png" />
              <span> Ganá 40 </span>
              <img className="modal-image" src="./images/coin.png" />
            </div>
            <div className="modal-text">
              <img className="modal-image" src="./images/apple.png" />
              <img className="modal-image" src="./images/apple.png" />
              <span> Ganá 10 </span>
              <img className="modal-image" src="./images/coin.png" />
            </div>
            <div className="modal-text">
              <img className="modal-image" src="./images/banana.png" />
              <img className="modal-image" src="./images/banana.png" />
              <span> Ganá 5 </span>
              <img className="modal-image" src="./images/coin.png" />
            </div>
            <div className="modal-text">
              Solo se considera un par en orden de izquierda a derecha.
            </div>
            <div>
              <div>
                <a>
                  © 2024 Bar Imperio.
                </a>
              </div>
            </div>
          </div>
        </div>
      </div>
  );
};

export default Modal;


=== cherry-charm\src\interface\modal\style.css ===

.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 2;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(31, 31, 31, 0.6);
}

.modal-box {
  background: #ffffff;
  width: min(85vw, 550px);
  height: fit-content;
  padding: 2vh min(8vw, 30px);
  border-radius: 40px;
  z-index: 3;
  text-align: center;
  box-shadow: 0 0 20px #ffffff;
}

.modal-text {
  font-family: "Inter", sans-serif;
  margin: 2vh 0;
  text-align: left;
  font-size: min(4vw, 20px);
  text-align: center;
}

.modal-image {
  width: min(6vw, 40px);
  margin: min(0.1em, 4px);
}

span {
  font-size: min(6vw, 40px);
}

a,
a:active,
a:visited {
  text-decoration: none;
  color: #000;
  font-size: min(3vw, 20px);
}


=== cherry-charm\src\lights\Lights.tsx ===



export default function Lights() {
  return (
    <>
      <directionalLight position={[-2, 3, 2]} intensity={1} />
      <directionalLight position={[2, 3, 2]} intensity={1} />
      <ambientLight intensity={0.5} />
    </>
  );
}


=== session_management\run.py ===

from imperioApp import app

if __name__ == '__main__':
    app.run(debug=True)


=== session_management\imperioApp\config.py ===

import os

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'your-secret-key'  # Replace with a secure random value
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URI') or 'sqlite:///app.db'
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    CHERRY_CHARM_URL = 'http://localhost:5173'


=== session_management\imperioApp\forms.py ===

from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, BooleanField, SubmitField
from wtforms.validators import DataRequired, Email, EqualTo, ValidationError
from .models import User

class LoginForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired()])
    password = PasswordField('Password', validators=[DataRequired()])
    remember_me = BooleanField('Remember Me')
    submit = SubmitField('Sign In')

class RegistrationForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired()])
    email = StringField('Email', validators=[DataRequired(), Email()])
    password = PasswordField('Password', validators=[DataRequired()])
    password2 = PasswordField(
        'Repeat Password', validators=[DataRequired(), EqualTo('password')])
    submit = SubmitField('Register')


=== session_management\imperioApp\models.py ===

from . import db, login_manager  # Relative imports
from flask_login import UserMixin
from werkzeug.security import generate_password_hash, check_password_hash

class User(UserMixin, db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(128), nullable=False)
    coins = db.Column(db.Integer, default=100, nullable=False)  # Add coins field

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def verify_password(self, password):
        return check_password_hash(self.password_hash, password)

    def __repr__(self):
        return f'<User {self.username}>'

@login_manager.user_loader
def load_user(user_id):
    return User.query.get(int(user_id))


=== session_management\imperioApp\reset_db.py ===

from . import db  # Relative import

def reset_database():
    db.drop_all()
    db.create_all()
    # Optionally, add initial data here

if __name__ == '__main__':
    reset_database()
    print("Database reset completed.")


=== session_management\imperioApp\routes.py ===

from flask import render_template, flash, redirect, url_for, request, jsonify, session
from flask_login import current_user, login_user, logout_user, login_required
from urllib.parse import urlparse
from . import app, db
from .forms import LoginForm, RegistrationForm
from .models import User
import jwt
import datetime
import logging

@app.route('/')
@app.route('/dashboard')
@login_required
def dashboard():
    return render_template('dashboard.html', title='Dashboard')

@app.route('/login', methods=['GET', 'POST'])
def login():
    if current_user.is_authenticated:
        return redirect(url_for('dashboard'))
    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        if user is None or not user.verify_password(form.password.data):
            flash('Invalid username or password')
            return redirect(url_for('login'))
        login_user(user, remember=form.remember_me.data)

        # Generate JWT token
        token = jwt.encode(
            {'user_id': user.username, 'exp': datetime.datetime.now(datetime.UTC) + datetime.timedelta(hours=1)},
            app.config['SECRET_KEY'],
            algorithm='HS256'
        )
        # Store token in session
        session['token'] = token
        session['username'] = user.username

        next_page = request.args.get('next')
        if not next_page or urlparse(next_page).netloc != '':
            next_page = url_for('dashboard')
        return redirect(next_page)
    return render_template('login.html', title='Sign In', form=form)

@app.route('/logout')
def logout():
    logout_user()
    session.pop('token', None)
    session.pop('username', None)
    return redirect(url_for('login'))

@app.route('/signup', methods=['GET', 'POST'])
def signup():
    if current_user.is_authenticated:
        return redirect(url_for('dashboard'))
    form = RegistrationForm()
    if form.validate_on_submit():
        # Check if username or email already exists
        existing_user = User.query.filter(
            (User.username == form.username.data) | (User.email == form.email.data)
        ).first()
        if existing_user:
            flash('Username or email already exists')
            return redirect(url_for('signup'))

        # Create new user with starting coins
        user = User(
            username=form.username.data,
            email=form.email.data,
            coins=100  # Assign starting coins here
        )
        user.set_password(form.password.data)
        db.session.add(user)
        db.session.commit()

        flash('Congratulations, you are now a registered user!')
        return redirect(url_for('login'))
    return render_template('signup.html', title='Register', form=form)

@app.route('/redirect-imperio')
@login_required
def redirect_to_imperio():
    username = current_user.username
    token = session.get('token')
    if not token:
        # Generate a new token if not present
        token = jwt.encode(
            {'user_id': current_user.username, 'exp': datetime.datetime.now(datetime.UTC) + datetime.timedelta(hours=12)},
            app.config['SECRET_KEY'],
            algorithm='HS256'
        )
        session['token'] = token
    return redirect(f"{app.config['CHERRY_CHARM_URL']}/?username={username}&token={token}")

@app.route('/verify-token', methods=['POST'])
def verify_token():
    data = request.get_json()
    token = data.get('token')
    username = data.get('username')

    if not token or not username:
        return jsonify({'message': 'Token and username are required'}), 400

    try:
        decoded_token = jwt.decode(token, app.config['SECRET_KEY'], algorithms=["HS256"])
        user = User.query.filter_by(username=decoded_token['user_id']).first()

        if user:
            return jsonify({'message': 'Token is valid'}), 200
        else:
            return jsonify({'message': 'Invalid token or username'}), 401

    except jwt.ExpiredSignatureError:
        return jsonify({'message': 'Token has expired'}), 401
    except jwt.InvalidTokenError:
        return jsonify({'message': 'Invalid token'}), 401

@app.route('/getCoins', methods=['GET'])
def get_coins():
    user_id = request.args.get('userId')
    logging.debug("Received getCoins request for user_id: %s", user_id)
    token = request.headers.get('Authorization').split(" ")[1] if request.headers.get('Authorization') else None

    if not user_id or not token:
        logging.warning("User ID or token is missing in getCoins request.")
        return jsonify({'message': 'User ID and token are required'}), 400

    try:
        decoded_token = jwt.decode(token, app.config['SECRET_KEY'], algorithms=["HS256"])
        if str(decoded_token['user_id']) != user_id:
            logging.debug(decoded_token['user_id'])
            logging.warning("Unauthorized access attempt for user_id: %s", user_id)
            return jsonify({'message': 'Unauthorized access'}), 401

        user = User.query.filter_by(username=user_id).first()
        if not user:
            logging.error("User not found for user_id: %s", user_id)
            return jsonify({'message': 'User not found'}), 404

        logging.info("Successfully retrieved coins for user_id: %s", user_id)
        return jsonify({'coins': user.coins}), 200

    except jwt.ExpiredSignatureError:
        logging.warning("Token has expired for user_id: %s", user_id)
        return jsonify({'message': 'Token has expired'}), 401
    except jwt.InvalidTokenError:
        logging.error("Invalid token received for user_id: %s", user_id)
        return jsonify({'message': 'Invalid token'}), 401

@app.route('/updateCoins', methods=['POST'])
def update_coins():
    data = request.get_json()
    user_id = data.get('userId')
    coins = data.get('coins')
    logging.debug("Received updateCoins request for user_id: %s with coins: %s", user_id, coins)
    token = request.headers.get('Authorization').split(" ")[1] if request.headers.get('Authorization') else None

    if not user_id or coins is None or not token:
        logging.warning("User ID, coins, or token is missing in updateCoins request.")
        return jsonify({'message': 'User ID, coins, and token are required'}), 400

    try:
        decoded_token = jwt.decode(token, app.config['SECRET_KEY'], algorithms=["HS256"])
        if str(decoded_token['user_id']) != user_id:
            logging.warning("Unauthorized update attempt for user_id: %s", user_id)
            return jsonify({'message': 'Unauthorized access'}), 401

        user = User.query.filter_by(username=user_id).first()
        if not user:
            logging.error("User not found for user_id: %s", user_id)
            return jsonify({'message': 'User not found'}), 404

        user.coins = coins
        db.session.commit()
        logging.info("Coins successfully updated for user_id: %s to %s coins", user_id, coins)
        return jsonify({'message': 'Coins updated successfully'}), 200

    except jwt.ExpiredSignatureError:
        logging.warning("Token has expired for user_id: %s", user_id)
        return jsonify({'message': 'Token has expired'}), 401
    except jwt.InvalidTokenError:
        logging.error("Invalid token received for user_id: %s", user_id)
        return jsonify({'message': 'Invalid token'}), 401

=== session_management\imperioApp\test_models.py ===

import unittest
from . import app, db
from .models import User

class UserModelCase(unittest.TestCase):
    def setUp(self):
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite://'
        app.config['TESTING'] = True
        self.app_context = app.app_context()
        self.app_context.push()
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()
        self.app_context.pop()

    def test_user_creation(self):
        u = User(username='testuser', email='test@example.com')
        u.set_password('testpass')
        db.session.add(u)
        db.session.commit()
        self.assertEqual(u.username, 'testuser')
        self.assertEqual(u.email, 'test@example.com')
        self.assertTrue(u.verify_password('testpass'))
        self.assertEqual(u.coins, 100)

    def test_user_coins_assignment(self):
        # Create a user with a specific coins value
        u = User(username='richuser', email='rich@example.com', coins=1000)
        u.set_password('richpass')
        db.session.add(u)
        db.session.commit()
        self.assertEqual(u.coins, 1000)

if __name__ == '__main__':
    unittest.main()


=== session_management\imperioApp\test_routes.py ===

import unittest
from unittest.mock import patch
from . import app, db
from .models import User
from flask import url_for, session
import jwt
import datetime
from urllib.parse import urlparse, parse_qs

class RoutesTestCase(unittest.TestCase):
    def setUp(self):
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite://'
        app.config['TESTING'] = True
        app.config['WTF_CSRF_ENABLED'] = False  # Disable CSRF for testing
        self.app = app.test_client()
        self.app_context = app.app_context()
        self.app_context.push()
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()
        self.app_context.pop()

    def register_user(self, username, email, password, password2):
        return self.app.post('/signup', data={
            'username': username,
            'email': email,
            'password': password,
            'password2': password2
        }, follow_redirects=True)

    def login_user(self, username, password):
        return self.app.post('/login', data={
            'username': username,
            'password': password
        }, follow_redirects=True)

    # Test for authenticated redirect to Imperio
    def test_redirect_to_imperio_authenticated(self):
        with patch('imperioApp.routes.requests.post') as mock_post:
            # Mock the external API call during signup
            mock_response = unittest.mock.Mock()
            mock_response.status_code = 201
            mock_response.content = b''
            mock_post.return_value = mock_response

            # Register and log in
            self.register_user('testuser', 'test@example.com', 'testpass', 'testpass')
            self.login_user('testuser', 'testpass')

        # Access the redirect route
        response = self.app.get('/redirect-imperio', follow_redirects=False)
        self.assertEqual(response.status_code, 302)  # Should redirect

        # Check the Location header for the correct redirection URL
        redirect_location = response.headers.get('Location')
        self.assertIsNotNone(redirect_location)

        # The URL should contain the username and token as query parameters
        parsed_url = urlparse(redirect_location)
        self.assertEqual(parsed_url.netloc, '13.60.215.133:5173')
        query_params = parse_qs(parsed_url.query)
        self.assertEqual(query_params.get('username'), ['testuser'])
        self.assertIn('token', query_params)

        # Optionally, verify the token
        token = query_params['token'][0]
        decoded_token = jwt.decode(token, app.config['SECRET_KEY'], algorithms=["HS256"])
        self.assertEqual(decoded_token['user_id'], 1)  # Assuming this is the first user

    # Test for unauthenticated redirect to Imperio
    def test_redirect_to_imperio_unauthenticated(self):
        # Try to access the redirect route without logging in
        response = self.app.get('/redirect-imperio', follow_redirects=True)
        self.assertIn(b'Please log in to access this page.', response.data)

    # Test for valid token verification
    def test_verify_token_valid(self):
        with patch('imperioApp.routes.requests.post') as mock_post:
            # Mock the external API call during signup
            mock_response = unittest.mock.Mock()
            mock_response.status_code = 201
            mock_response.content = b''
            mock_post.return_value = mock_response

            # Register and log in
            self.register_user('testuser', 'test@example.com', 'testpass', 'testpass')
            self.login_user('testuser', 'testpass')

        # Retrieve the token from the session
        with self.app as client:
            with client.session_transaction() as sess:
                token = sess['token']

        # Prepare the data
        data = {
            'token': token,
            'username': 'testuser'
        }
        # Send POST request to /verify-token
        response = self.app.post('/verify-token', json=data)
        self.assertEqual(response.status_code, 200)
        self.assertIn(b'"message": "Token is valid"', response.data)

    # Test for invalid token verification
    def test_verify_token_invalid_token(self):
        # Prepare invalid token data
        data = {
            'token': 'invalidtoken',
            'username': 'testuser'
        }
        # Send POST request to /verify-token
        response = self.app.post('/verify-token', json=data)
        self.assertEqual(response.status_code, 401)
        self.assertIn(b'"message": "Invalid token"', response.data)

    # Test for expired token verification
    def test_verify_token_expired_token(self):
        with patch('imperioApp.routes.requests.post') as mock_post:
            # Mock the external API call during signup
            mock_response = unittest.mock.Mock()
            mock_response.status_code = 201
            mock_response.content = b''
            mock_post.return_value = mock_response

            # Register and log in
            self.register_user('testuser', 'test@example.com', 'testpass', 'testpass')
            self.login_user('testuser', 'testpass')

        expired_token = jwt.encode(
            {'user_id': 1, 'exp': datetime. datetime. now(datetime. UTC) - datetime.timedelta(hours=1)},
            app.config['SECRET_KEY'],
            algorithm='HS256'
        )
        data = {
            'token': expired_token,
            'username': 'testuser'
        }
        response = self.app.post('/verify-token', json=data)
        self.assertEqual(response.status_code, 401)
        self.assertIn(b'"message": "Token has expired"', response.data)

    # Test for username mismatch in token verification
    def test_verify_token_username_mismatch(self):
        with patch('imperioApp.routes.requests.post') as mock_post:
            # Mock the external API call during signup
            mock_response = unittest.mock.Mock()
            mock_response.status_code = 201
            mock_response.content = b''
            mock_post.return_value = mock_response

            # Register and log in
            self.register_user('testuser', 'test@example.com', 'testpass', 'testpass')
            self.login_user('testuser', 'testpass')

        # Retrieve the token from the session
        with self.app as client:
            with client.session_transaction() as sess:
                token = sess['token']

        # Prepare data with a different username
        data = {
            'token': token,
            'username': 'otheruser'
        }
        # Send POST request to /verify-token
        response = self.app.post('/verify-token', json=data)
        self.assertEqual(response.status_code, 401)
        self.assertIn(b'"message": "Invalid token or username"', response.data)

    # Test for missing fields in token verification
    def test_verify_token_missing_fields(self):
        # Missing token
        data = {'username': 'testuser'}
        response = self.app.post('/verify-token', json=data)
        self.assertEqual(response.status_code, 400)
        self.assertIn(b'"message": "Token and username are required"', response.data)

        # Missing username
        data = {'token': 'sometoken'}
        response = self.app.post('/verify-token', json=data)
        self.assertEqual(response.status_code, 400)
        self.assertIn(b'"message": "Token and username are required"', response.data)

    # Test for successful signup with mocked external API
    @patch('imperioApp.routes.requests.post')
    def test_signup_successful_external_api(self, mock_post):
        # Mock the external API response to simulate successful user creation
        mock_response = unittest.mock.Mock()
        mock_response.status_code = 201
        mock_response.content = b''
        mock_post.return_value = mock_response

        # Register a new user
        response = self.register_user('testuser', 'test@example.com', 'testpass', 'testpass')
        self.assertIn(b'Congratulations, you are now a registered user!', response.data)

        # Ensure the external API was called with correct parameters
        mock_post.assert_called_once()
        args, kwargs = mock_post.call_args
        self.assertEqual(args[0], app.config['EXTERNAL_API_URL'])
        self.assertEqual(kwargs['json'], {'userId': 'testuser'})
        self.assertIn('Authorization', kwargs['headers'])
        self.assertTrue(kwargs['headers']['Authorization'].startswith('Bearer '))

    # Test for signup failure due to external API
    @patch('imperioApp.routes.requests.post')
    def test_signup_external_api_failure(self, mock_post):
        # Mock the external API response to simulate failure
        mock_response = unittest.mock.Mock()
        mock_response.status_code = 400
        mock_response.json.return_value = {'error': 'User creation failed'}
        mock_response.text = '{"error": "User creation failed"}'
        mock_post.return_value = mock_response

        # Register a new user
        response = self.register_user('testuser', 'test@example.com', 'testpass', 'testpass')
        self.assertIn(b'Error creating user on backend: User creation failed', response.data)

        # Ensure the external API was called with correct parameters
        mock_post.assert_called_once()
        args, kwargs = mock_post.call_args
        self.assertEqual(args[0], app.config['EXTERNAL_API_URL'])
        self.assertEqual(kwargs['json'], {'userId': 'testuser'})
        self.assertIn('Authorization', kwargs['headers'])
        self.assertTrue(kwargs['headers']['Authorization'].startswith('Bearer '))

    # Test for signup with non-JSON response from external API
    @patch('imperioApp.routes.requests.post')
    def test_signup_external_api_non_json_response(self, mock_post):
        # Mock the external API response to return non-JSON content
        mock_response = unittest.mock.Mock()
        mock_response.status_code = 500
        mock_response.json.side_effect = ValueError("No JSON")
        mock_response.text = 'Internal Server Error'
        mock_post.return_value = mock_response

        # Register a new user
        response = self.register_user('testuser', 'test@example.com', 'testpass', 'testpass')
        self.assertIn(b'Error creating user on backend: Non-JSON response: Internal Server Error', response.data)

        # Ensure the external API was called with correct parameters
        mock_post.assert_called_once()
        args, kwargs = mock_post.call_args
        self.assertEqual(args[0], app.config['EXTERNAL_API_URL'])
        self.assertEqual(kwargs['json'], {'userId': 'testuser'})
        self.assertIn('Authorization', kwargs['headers'])
        self.assertTrue(kwargs['headers']['Authorization'].startswith('Bearer '))

    # Test for duplicate username during signup
    @patch('imperioApp.routes.requests.post')
    def test_signup_duplicate_username(self, mock_post):
        # Mock the external API call during signup
        mock_response = unittest.mock.Mock()
        mock_response.status_code = 201
        mock_response.content = b''
        mock_post.return_value = mock_response

        # First registration
        self.register_user('testuser', 'test@example.com', 'testpass', 'testpass')
        # Attempt to register the same user again
        response = self.register_user('testuser', 'test2@example.com', 'testpass', 'testpass')
        self.assertIn(b'Username or email already exists', response.data)

    # Test for duplicate email during signup
    @patch('imperioApp.routes.requests.post')
    def test_signup_duplicate_email(self, mock_post):
        # Mock the external API call during signup
        mock_response = unittest.mock.Mock()
        mock_response.status_code = 201
        mock_response.content = b''
        mock_post.return_value = mock_response

        # First registration
        self.register_user('testuser', 'test@example.com', 'testpass', 'testpass')
        # Attempt to register with the same email
        response = self.register_user('testuser2', 'test@example.com', 'testpass', 'testpass')
        self.assertIn(b'Username or email already exists', response.data)

if __name__ == '__main__':
    unittest.main()


=== session_management\imperioApp\__init__.py ===

from flask import Flask
from flask_migrate import Migrate
from flask_sqlalchemy import SQLAlchemy
from flask_login import LoginManager
from .config import Config  # Use relative import
import logging
from flask_cors import CORS

# Set up logging
logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s %(levelname)s %(name)s %(threadName)s : %(message)s',
                    handlers=[
                        logging.FileHandler("app_debug.log"),
                        logging.StreamHandler()
                    ])

app = Flask(__name__)
app.config.from_object(Config)
CORS(app, resources={r"/*": {"origins": "*"}})

db = SQLAlchemy(app)
migrate = Migrate(app, db)  # Initialize Migrate
login_manager = LoginManager(app)
login_manager.login_view = 'login'

from . import routes, models  # Use relative imports


=== session_management\imperioApp\static\css\styles.css ===

body {
    font-family: Arial, sans-serif;
    margin: 20px;
}
h2 {
    color: #333;
}
.flashes {
    list-style-type: none;
    padding: 0;
}
.flashes li {
    background-color: #f2dede;
    color: #a94442;
    padding: 10px;
    margin-bottom: 10px;
}


